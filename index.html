<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Joske's Picks Website Generator with Circular PNG Base64</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 20px;
    background: #fafafa;
  }
  h2 { color: #54160d; }
  label { display: block; margin-top: 8px; }
  input, button {
    padding: 6px;
    width: 100%;
    margin-top: 2px;
    box-sizing: border-box;
  }
  .restaurant {
    border: 1px solid #ccc;
    padding: 10px;
    margin-bottom: 12px;
    background: #fff;
    position: relative;
  }
  button {
    background: #54160d;
    color: white;
    border: none;
    cursor: pointer;
    font-size: 16px;
  }
  button:hover {
    background: #7a2015;
  }
  .preview {
    position: absolute;
    right: 10px;
    top: 10px;
    width: 60px;
    height: 60px;
    border-radius: 50%;
    border: 2px solid #54160d;
    object-fit: cover;
    background: #eee;
  }
</style>

<!-- Load Google Maps API with Places library -->
<script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBGxMWMZqAdme8MEVOBxl-GzJjCujz9STU&libraries=places"></script>
</head>
<body>
  <h1>Joske's Picks Website Generator</h1>
  <form id="siteForm">
    <h2>Property Info</h2>
    <label>Property Name:</label>
    <input type="text" name="propertyName" required />

    <label>Property Address:</label>
    <input type="text" name="propertyAddress" required />

    <h2>Restaurants</h2>
    <div id="restaurants"></div>

    <button type="submit">Generate Website</button>
  </form>

  <canvas id="canvas" style="display:none;"></canvas>

  <script>
    // Add 5 restaurant input blocks (without place ID input)
    const restContainer = document.getElementById("restaurants");
    for (let i = 0; i < 5; i++) {
      restContainer.insertAdjacentHTML(
        "beforeend",
        `
        <div class="restaurant" data-index="${i}">
          <h3>Restaurant ${i + 1}</h3>
          <label>Name:</label>
          <input type="text" name="restName[]" required />

          <label>Address:</label>
          <input type="text" name="restAddress[]" required />

          <label>Upload Thumbnail Image:</label>
          <input type="file" accept="image/*" name="restImageFile[]" required />

          <img class="preview" alt="Image Preview" />
          <input type="hidden" name="restImageBase64[]" />
        </div>
      `
      );
    }

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    // Convert image file to circular PNG base64
    async function convertToCircularBase64(file) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        const url = URL.createObjectURL(file);

        img.onload = () => {
          const size = Math.min(img.width, img.height);
          canvas.width = size;
          canvas.height = size;

          ctx.clearRect(0, 0, size, size);

          ctx.save();
          ctx.beginPath();
          ctx.arc(size / 2, size / 2, size / 2, 0, Math.PI * 2);
          ctx.closePath();
          ctx.clip();

          let sx = 0, sy = 0;
          if (img.width > img.height) {
            sx = (img.width - img.height) / 2;
          } else {
            sy = (img.height - img.width) / 2;
          }

          ctx.drawImage(img, sx, sy, size, size, 0, 0, size, size);
          ctx.restore();

          const dataUrl = canvas.toDataURL('image/png');

          URL.revokeObjectURL(url);
          resolve(dataUrl.replace(/^data:image\/png;base64,/, '')); // Return base64 string only
        };

        img.onerror = () => {
          URL.revokeObjectURL(url);
          reject('Failed to load image.');
        };

        img.src = url;
      });
    }

    // Listen for image input changes to auto-convert and preview
    restContainer.addEventListener('change', async (e) => {
      if (e.target && e.target.name === 'restImageFile[]') {
        const input = e.target;
        const file = input.files[0];
        if (!file) return;

        const restaurantDiv = input.closest('.restaurant');
        const previewImg = restaurantDiv.querySelector('.preview');
        const hiddenInput = restaurantDiv.querySelector('input[name="restImageBase64[]"]');

        try {
          const base64 = await convertToCircularBase64(file);
          hiddenInput.value = base64;
          previewImg.src = `data:image/png;base64,${base64}`;
        } catch (err) {
          alert(err);
          hiddenInput.value = "";
          previewImg.src = "";
        }
      }
    });

    // Geocode helper using Google Maps API
    function geocodeAddress(address) {
      return new Promise((resolve, reject) => {
        const geocoder = new google.maps.Geocoder();
        geocoder.geocode({ address: address }, (results, status) => {
          if (status === "OK" && results[0]) {
            const loc = results[0].geometry.location;
            resolve({ lat: loc.lat(), lng: loc.lng() });
          } else {
            reject(`Geocode failed for: ${address} (status: ${status})`);
          }
        });
      });
    }

    // Get placeId from Google Places Text Search API
    function getPlaceId(name, address) {
      return new Promise((resolve, reject) => {
        const service = new google.maps.places.PlacesService(document.createElement('div'));
        const query = `${name} ${address}`;

        service.textSearch({ query: query }, (results, status) => {
          if (status === google.maps.places.PlacesServiceStatus.OK && results.length > 0) {
            resolve(results[0].place_id);
          } else {
            reject(`Place ID not found for: ${name} (${address})`);
          }
        });
      });
    }

    document.getElementById("siteForm").addEventListener("submit", async function (e) {
      e.preventDefault();

      const form = new FormData(this);
      const propertyName = form.get("propertyName");
      const propertyAddress = form.get("propertyAddress");

      let propertyLatLng;
      try {
        propertyLatLng = await geocodeAddress(propertyAddress);
      } catch (err) {
        alert(err);
        return;
      }

      const restNames = form.getAll("restName[]");
      const restAddresses = form.getAll("restAddress[]");
      const restImagesBase64 = form.getAll("restImageBase64[]");

      const restaurants = [];

      for (let i = 0; i < restNames.length; i++) {
        if (!restImagesBase64[i]) {
          alert(`Image not processed for restaurant: ${restNames[i]}. Please re-upload the image.`);
          return;
        }

        let latLng;
        let placeId;
        try {
          placeId = await getPlaceId(restNames[i], restAddresses[i]);
          latLng = await geocodeAddress(restAddresses[i]);
        } catch (err) {
          alert(err);
          return;
        }

        restaurants.push({
          title: restNames[i],
          position: latLng,
          placeId: placeId,
          base64Image: restImagesBase64[i].trim()
        });
      }

      // Fetch template.html file (make sure it exists in same folder)
      let template;
      try {
        template = await fetch("template.html").then(r => r.text());
      } catch {
        alert("Failed to load template.html file.");
        return;
      }

      // Replace placeholders
      template = template
        .replace(/__PROPERTY_LAT__/g, propertyLatLng.lat)
        .replace(/__PROPERTY_LNG__/g, propertyLatLng.lng)
        .replace(/__RESTAURANTS_JSON__/g, JSON.stringify(restaurants, null, 2))
        .replace(/__PROPERTY_NAME__/g, propertyName);

      // Trigger file download of generated HTML
      const blob = new Blob([template], { type: "text/html" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "joske-map.html";
      a.click();
      URL.revokeObjectURL(url);
    });
  </script>
</body>
</html>
